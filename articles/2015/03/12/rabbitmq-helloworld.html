<!DOCTYPE html><html><head><title>RabbitMQ 教程系列第一部分 Hello World - Chareice</title><meta charset=UTF-8 /><meta content="width=device-width, initial-scale=1.0, user-scalable=no" name=viewport /><link href="/images/favicon.ico" rel="shortcut icon"/><link href="/stylesheets/index.css" rel=stylesheet /><link href="//dn-chareicecnd.qbox.me/solarized_dark.css" rel=stylesheet /></head><body><header><a href="/" id=go-back-home><img alt=Home height=100 src="/images/blog_logo.png" width=100 /></a><p>Chareice</p><p>Hi, I'm Chareice, A Web Developer.</p></header><div id=container><div class=block><a href="/articles/tags/rabbitmq.html">RabbitMQ</a><a href="/articles/tags/java.html">Java</a><a href="/articles/tags/算法.html">算法</a><a href="/articles/tags/计算机科学基础.html">计算机科学基础</a><a href="/articles/tags/python.html">Python</a><a href="/articles/tags/ruby.html">Ruby</a><a href="/articles/tags/rails.html">Rails</a></div><div class=content><section class=post><header><div class=date>12 Mar 2015</div><h1>RabbitMQ 教程系列第一部分 Hello World</h1></header><div id=toc class=toc> <div id=toctitle class=title>本文目录</div> <ul class=sectlevel1> <li><a href="#_简介">1. 简介</a></li> <li><a href="#__hello_world">2. "Hello World"</a> <ul class=sectlevel2> <li><a href="#_发送">2.1. 发送</a></li> <li><a href="#_接收">2.2. 接收</a></li> </ul> </li> </ul> </div> <div class=sect1> <h2 id="_简介">1. 简介</h2> <div class=sectionbody> <div class=paragraph> <p>RabbitMQ是一个消息代理。从本质上说，它接受生产者(producers)的消息，然后把这些消息交付给消费者(consumers)。 在这之间，它可以根据你制定的规则来制定消息的路径，缓冲消息，持久化消息。</p> </div> <div class=paragraph> <p>RabbitMQ，或者说信息传递，使用到的一些术语。</p> </div> <div class=ulist> <ul> <li> <p>生产(Producing)意味着发送，一个发送消息的程序，可以称作生产者(producer)。我们可以这么表示。</p> </li> </ul> </div> <div class=imageblock> <div class=content> <img src="https://www.rabbitmq.com/img/tutorials/producer.png" alt=producer> </div> </div> <div class=ulist> <ul> <li> <p>队列(Queue)，是一个信箱的名称，它存在于RabbitMQ的内部。尽管消息流在RabbitMQ和你的应用程序之间穿过， 但是它们也可以只被存储在队列中。一个队列没有绑定任何的限制，它可以存储你希望的，尽可能多的信息&#8201;&#8212;&#8201;实际上 它是一个无限大小的缓冲区。许多不同的生产者可以发送消息到同一个队列中，不同的消费者也可以从同一个队列中读取消息。 一个队列可以被绘制为下面这张图，图形上面写队列的名字。</p> </li> </ul> </div> <div class=imageblock> <div class=content> <img src="https://www.rabbitmq.com/img/tutorials/queue.png" alt=queue> </div> </div> <div class=ulist> <ul> <li> <p>消费(Consuming)和接收是同一个意思。一个消费者是一个等待接收消息的应用程序。可以用如下图形表示。</p> </li> </ul> </div> <div class=imageblock> <div class=content> <img src="https://www.rabbitmq.com/img/tutorials/consumer.png" alt=consumer> </div> </div> <div class=paragraph> <p>需要注意的是，生产者、消费者和消息代理不需要在同一台机器上，实际上在应用中也是这个情况。</p> </div> </div> </div> <div class=sect1> <h2 id=__hello_world>2. "Hello World"</h2> <div class=sectionbody> <div class=paragraph> <p>在这一部分我们将使用Ruby编写两个小程序。一个生产者发送单条信息，一个消费者接收这条信息然后将其打印出来。 我们将掩盖一些 <strong>Bunny</strong> API的细节，全神贯注地做简单的事情。</p> </div> <div class=paragraph> <p>如下面的图形所示，"P"是我们的生产者，"C"是我们的消费者。在中间的盒子是一个队列&#8201;&#8212;&#8201;一个RabbitMQ的消息缓冲区，代表消费者。</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class=icon> <i class="fa icon-tip" title=Tip></i> </td> <td class=content> RabbitMQ使用AMQP 0.9.1 协议，这是一个开源的消息传递协议。RabbitMQ有多种不同的客户端实现，在这个教程中我们将使用Bunny。 </td> </tr> </table> </div> <div class=sect2> <h3 id="_发送">2.1. 发送</h3> <div class=imageblock> <div class=content> <img src="https://www.rabbitmq.com/img/tutorials/sending.png" alt=sending> </div> </div> <div class=paragraph> <p>我们称我们的消息发送为 <code>send.rb</code> ，消息接收为 <code>receive.rb</code>。 发送者将连接上RabbitMQ，发送一条消息然后退出。</p> </div> <div class=paragraph> <p>在 <code>send.rb</code> 中，首先我们需要引入 Bunny 库。</p> </div> <div class=listingblock> <div class=content> <pre class="CodeRay highlight"><code data-lang="ruby"><span style="color:#34b">#!/usr/bin/env ruby</span>
<span style="color:#777"># encoding: utf-8</span>

require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">bunny</span><span style="color:#710">&quot;</span></span></code></pre> </div> </div> <div class=paragraph> <p>接下来连接 RabbitMQ 服务器。</p> </div> <div class=listingblock> <div class=content> <pre class="CodeRay highlight"><code data-lang="ruby">conn = <span style="color:#036;font-weight:bold">Bunny</span>.new
conn.start</code></pre> </div> </div> <div class=paragraph> <p>连接抽象了socket连接，并且帮我们处理了协议层的对接。现在我们使用默认的设置连接本地机器上的消息代理服务器。</p> </div> <div class=paragraph> <p>如果我们想要连接一个远程端口的消息代理，我们可以通过 <code>:hostname</code> 选项来指定不同的服务器地址。</p> </div> <div class=listingblock> <div class=content> <pre class="CodeRay highlight"><code data-lang="ruby">conn = <span style="color:#036;font-weight:bold">Bunny</span>.new(<span style="color:#A60">:hostname</span> =&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">rabbit.local</span><span style="color:#710">&quot;</span></span>)
conn.start</code></pre> </div> </div> <div class=paragraph> <p>下面我们创建一个通道，通道是大多数API完成任务的地方。</p> </div> <div class=listingblock> <div class=content> <pre class="CodeRay highlight"><code data-lang="ruby">ch = conn.create_channel</code></pre> </div> </div> <div class=paragraph> <p>要发送消息，我们必须声明我们要发送的队列，这样我们就可以向队列中发送消息。</p> </div> <div class=listingblock> <div class=content> <pre class="CodeRay highlight"><code data-lang="ruby">q = ch.queue(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">hello</span><span style="color:#710">'</span></span>)
ch.default_exchange.publish(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello World</span><span style="color:#710">&quot;</span></span>, <span style="color:#A60">:routing_key</span> =&gt; q.name)
puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> [x] Send 'Hello World!'</span><span style="color:#710">&quot;</span></span></code></pre> </div> </div> <div class=paragraph> <p>声明一个队列是幂等的，只有在该队列没有创建的时候才会被创建。消息的内容是字节数组，所以你可以编码任何你想要的。</p> </div> <div class=paragraph> <p>最后，关闭连接。</p> </div> <div class=listingblock> <div class=content> <pre class="CodeRay highlight"><code data-lang="ruby">conn.close</code></pre> </div> </div> </div> <div class=sect2> <h3 id="_接收">2.2. 接收</h3> <div class=paragraph> <p>刚才是我们的生产者，发送消息。我们的接收者是要从RabbitMQ一直接收消息，所以不同于消息发送者，我们的接收者必须一直运行监听消息。</p> </div> <div class=imageblock> <div class=content> <img src="https://www.rabbitmq.com/img/tutorials/receiving.png" alt=receiving> </div> </div> <div class=paragraph> <p><code>receive.rb</code> 也和 <code>send.rb</code> 一样，要先引入 <code>Bunny</code>。</p> </div> <div class=listingblock> <div class=content> <pre class="CodeRay highlight"><code data-lang="ruby"><span style="color:#34b">#!/usr/bin/env ruby</span>
<span style="color:#777"># encoding: utf-8</span>

require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">bunny</span><span style="color:#710">&quot;</span></span></code></pre> </div> </div> <div class=paragraph> <p>设置连接也是和 <code>sender</code> 一样。我们打开一个连接和一个通道，并且定义我们想要监听消息的队列名称，这里要注意的是监听的队列名称要和消息发布的一致。</p> </div> <div class=listingblock> <div class=content> <pre class="CodeRay highlight"><code data-lang="ruby">conn = <span style="color:#036;font-weight:bold">Bunny</span>.new
conn.start

ch = conn.create_channel
q = ch.queue(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">hello</span><span style="color:#710">'</span></span>)</code></pre> </div> </div> <div class=paragraph> <p>需要注意的是，我们在这里声明了队列名称，因为也许我们的接受者会比发送者更早一步运行，我们必须要确保我们要消费的这个队列是存在的。</p> </div> <div class=paragraph> <p>我们将要告诉服务器我们需要从这个队列里面接收消息，之后服务器就会异步地推送消息给我们的消费者，我们提供了一个将会在消息推送过来时运行的回调。</p> </div> <div class=listingblock> <div class=content> <pre class="CodeRay highlight"><code data-lang="ruby">puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20"> [*] Waiting for messages in #{q.name}. To exit press CTRL+C</span><span style="color:#710">'</span></span>
q.subscribe(<span style="color:#A60">:block</span> =&gt; <span style="color:#069">true</span>) <span style="color:#080;font-weight:bold">do</span> |delivery_info, properties, body|
  puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20"> [x] Received #{body}</span><span style="color:#710">'</span></span>

  delivery_info.consumer.cancel
<span style="color:#080;font-weight:bold">end</span></code></pre> </div> </div> <div class=paragraph> <p><code>Bunny::Queue#subscribe</code> 方法使用 <code>:block</code> 参数来阻塞线程。</p> </div> </div> </div> </div></section></div><div class=block> <div id=disqus_thread></div> <div id=load_comments>Load Comments</div> </div> </div><footer><span class=muted>© Chareice. All Rights Reserved.</span><br/><span class=muted>This work is licensed under a <a href="//creativecommons.org/licenses/by-nc-sa/3.0/deed.zh">CC BY-NC-SA 3.0.</a></span><br/><span class=muted>赣ICP备14009574号-3</span></footer><script src="/javascripts/all.js"></script><script src="//dn-chareicecnd.qbox.me/highlight.min.js"></script><script>hljs.initHighlightingOnLoad()</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-39536235-1','auto');ga('send','pageview');</script> </body></html>